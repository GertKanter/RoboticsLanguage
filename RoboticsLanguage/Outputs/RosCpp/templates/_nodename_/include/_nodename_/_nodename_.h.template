/*
 * Node name: {{parameters['node']['name']}}
 *
 * Generated on: {{"%d %B, %Y"|todaysDate}}
 *       Author: {{parameters['Information']['user']['name']}}
 *      Licence: {{parameters['Information']['software']['license']}}
 *    Copyright: {{parameters['Information']['software']['copyright']}}
 *
 *    THIS FILE WAS AUTOMATICALLY GENERATED USING THE ROBOTICS LANGUAGE
 *
 */
#ifndef {{parameters['node']['name']|underscoreFullCaps}}_{{parameters['node']['name']|underscoreFullCaps}}_H
#define {{parameters['node']['name']|underscoreFullCaps}}_{{parameters['node']['name']|underscoreFullCaps}}_H

// Base libraries
#include <ros/ros.h>
#include <tuple>
//FSM Libraries
#include <iostream>
#include <vector>
#include <map>
#include <exception>
#include <functional>

// extra global includes
{% for library in parameters['Outputs']['RosCpp']['globalIncludes'] -%}
#include <{{library}}>
{% endfor -%}

class FiniteStateMachine {
public:
	FiniteStateMachine()
		{
				std::cout<< "Creating FSM" << std::endl;
				this->addState("a");
				currentState = machine.begin()->first;;
		};
	FiniteStateMachine(std::string name)
	{
		std::cout<< "Creating FSM with name: " << name << std::endl;
		this->addState(name);
		currentState = machine.begin()->first;;
	};

	~FiniteStateMachine(){};

	void addState(std::string name) {
		std::cout << "Adding state " << name << " with empty transition"
				<< std::endl;

		std::map<std::string, std::string> transition;

		machine.insert(
				std::pair<std::string, std::map<std::string, std::string> >(
						name, transition));
	}
	void addTransition(std::string arc, std::string begin, std::string end) {
		try {
			machine[begin].insert(
					std::pair<std::string, std::string>(arc, end));
			std::cout << "Added transition " << arc << " with begin " << begin
					<< " and end " << end << std::endl;
		} catch (std::exception & e) {
			std::cout << "Failed to insert Transition" << std::endl;
		}
	}

	void fire(std::string trans) {
		std::map<std::string, std::string> transition;
		std::map<std::string, std::function<void()> >::iterator initIter,
				exitIter;

		//Trying to run Init function
		transition = machine[currentState];
		std::map<std::string, std::string>::iterator iter = transition.find(
				trans);

		if (iter != transition.end()) {
			std::cout << "Transition " << trans << " from current state: "
					<< currentState << " to " << machine[currentState].find(trans)->second << std::endl;
			//Try to run exit function of previous
			exitIter = exitState.find(currentState);
			if (exitIter != exitState.end()) {
				std::cout << "Executing exit function of " << currentState << std::endl;
				(exitIter->second)();
			}

			currentState = iter->second;
			initIter = initState.find(currentState);
			if (initIter != initState.end()) {
				std::cout << "Executing init of "
						<< currentState << std::endl;
				(initIter->second)();
			}
			this->printCurrentState();

		} else {
			std::cout << "Invalid transition..."
					<< std::endl;

		}

	}

	void addInitState(std::string state, void (*func)()) {
		if (*func != NULL) {
			std::cout << "Adding init state function to " << state << std::endl;
			initState.insert(
					std::pair<std::string, std::function<void()> >(state,
							(*func)));
		} else {
			std::cout << "No function passed.. item not added..." << std::endl;
		}
	}
	void addExitState(std::string state, void (*func)()) {
		if (*func != NULL) {
			std::cout << "Adding exit state function to " << state << std::endl;
			exitState.insert(
					std::pair<std::string, std::function<void()> >(state,
							(*func)));
		} else {
			std::cout << "No function passed.. item not added..." << std::endl;
		}
	}

	void printCurrentState() {
		std::cout << "Current state: " << currentState << std::endl;
	}

	void setCurrentState(std::string state)
	{
		currentState = state;
	}
	void printFSM() {
		std::cout << "\n\n\nCurrent State Machine: " << std::endl;
		for (auto it = machine.begin(); it != machine.end(); it++) {
			std::cout << "State: " << it->first << std::endl;
			std::map<std::string, std::string>::iterator transIter =
					it->second.begin();
			std::cout << "Transitions" << std::endl;
			for (; transIter != it->second.end(); transIter++) {
				std::cout << transIter->first << " to " << transIter->second
						<< std::endl;
			}
			std::cout << std::endl;
		}

	}


private:
	std::map<std::string, std::map<std::string, std::string> > machine; //A transition has a number and a destination state
	std::map<std::string, std::function<void()> > initState, exitState;
	std::string currentState;

};



/***************************************************************************************
*       {{parameters['node']['name']|camelCase }}Class Declaration
****************************************************************************************/
namespace {{parameters['node']['name']|underscore}}
{
  class {{parameters['node']['name']|camelCase }}Class
  {
    public:

      // Constructor
      {{parameters['node']['name']|camelCase }}Class();

      /*!
       * @brief Spins the node (checks for ros callbacks)
       */
      void spin();

      /*!
       * @brief initialise initializes anything needed for this node
       */
      virtual void initialise();

      /*!
       * @brief finalise the last code to run before node stops
       */
      virtual void finalise();

    private:

      // The ROS node handle
      ros::NodeHandle nh_; /**< "Global" NodeHandle */

      /* definitions */
      {{code|xpath('/node')|option('definitions')|attribute('RosCpp')}};

      {# ROS TOPICS #################################### #}
      {% if parameters['Transformers']['ROS']['topicDefinitions']|length > 0 -%}
      /* ROS topics */
        {% for topic in parameters['Transformers']['ROS']['topicDefinitions'] -%}
      /* signal {{topic['variable']}} */
        {# PUBLISHER #################################### #}
          {% if topic['flow'] == 'outgoing' or topic['flow'] == 'bidirectional' -%}
      ros::Publisher {{topic['variable']}}_publisher;
          {% endif -%}

          {# SUBSCRIBER + CALLBACK #################################### #}
          {% if topic['flow'] == 'incoming' or topic['flow'] == 'bidirectional' -%}
      ros::Subscriber {{topic['variable']}}_subscriber;
      void signal_{{topic['variable']}}_callback(const {{topic['ros_type']}}& message);
          {% endif -%}


      {{topic['ros_type']}} {{topic['variable']}};

        {% endfor %}
      {% endif -%}
  };
}

#endif // {{parameters['node']['name']|underscoreFullCaps }}_{{parameters['node']['name']|underscoreFullCaps }}_H
